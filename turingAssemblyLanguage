;program guidelines:
;	r0 has a memAddress
;	r1 has the content of that address
;	r2 stores the tapePointer
;	r3 does not store anything, just used for comparisons
;	r4 stores the tupleNumber of the current tuple being looked at for comparison
;
;Right now the program is for 5 tuples, if there are not 5 tuples then the code is modified slightly
; in executeDirection, nextTuple, and tapePointer. Please also note that if you change the tape 
; such that it has a different length, you must also edit tapeLength accordingly (tapeLength is the 
; length of the tape including the underscores)
;

;take note that each .tuple takes up 7 memory locations
Tuple01:  .tuple \ 0 _ 0 _ 1\ ; mem[0-6]
Tuple02:  .tuple \ 0 1 1 0 1\ ; mem[7-13]
Tuple03:  .tuple \ 0 0 1 1 1\ ; mem[14-20]
Tuple04:  .tuple \ 1 0 1 1 1\ ; mem[21-27]
Tuple05:  .tuple \ 1 1 1 0 1\ ; mem[28-34]

Tape:  .String “_010101_” ; mem[35-43]
tapePointer:  .Integer #36 ; not 35 since that holds length of tape
;	note that if tapePointer is <=35 of >=44 then it is out of bounds, this is very important in
;	execute direction
tapeLength:  .Integer #8

numTuples:  .Integer #5
currentState:  .Integer #0















findTuple: jsr getTupleAddress ; memory address of the tuple is in r0, pointing to \
	jsr incrementTupleAddress ; r0 now pointing to the cs of the tuple
	movxr r0 r1 ; r1 contains cs of the tuple
	cmpmr currentState r1
	jmpz checkic ; if the current states match, then the ic comparison is next
	jmpnz nextTuple ; tuple cs does not match, move to next tuple comparison
	
nextTuple: addir #1 r4 ; tuple number increased by 1
	cmpir #6 r4 ; to see if all tuples have been checked
	jmpz end
	jmpnz  findTuples

checkic: jsr incrementTupleAddress ; r0 points to ic of the tuple
movmr tapePointer r2 ; pointer is in r2
movxr r2 r3 ; r3 has specific character of the tape
movxr r0 r1 ; r1 has ic of the tuple
cmprr r1 r3 ; compares character of tape with ic of tuple
jmpz executeTuple ; executes tuple if cs and ic match
jmpnz nextTuple

incrementTupleAddress: addir #1 r0
	ret

; tupleAddress = 7(tupleNumber - 1)
getTupleAddress: movrr r4 r0
	subir #1 r0
	mulir #7 r0
	ret

executeTuple: addir #1 r0 ; tupleAddress now points to ns
	movxr r0 r1 ; ns in r1
	movrm r1 currentState ; currentState now set to the tuple’s ns
	addir #1 r0 ; tupleAddress now points to oc
	movxx r1 r2 ; tape character becomes tuple’s oc
	jmp executeDirection








executeDirection: addir #1 r0 ; tuple address now points to di
	movxr r0 r1 ; di in r1, note that 1 is right, -1 is left
	cmpir #0 r1
	jmpp goLeft ; goes left if r1 is -1, or left
	jmpn goRight ; goes right if r1 is 1, or right

goLeft: subir #1 r2 ; tapePointer moved to the left
	jmp checkEndTape

goRight: addir #1 r2 ; tapePointer moved to the right
	jmp checkEndTape

;tapePointer is out of tape if <= 35 or >= 44
checkEndTape: movir #35 r3
	cmprr r2 r3 ; r2 holds tapePointer
	jmpz end
	addir #1 r3
	addmr tapeLength r3 ; r3 should now hold the first memory address past tape
	cmprr r2 r3
	jmpz end; if it goes past this then not at end of tape, go back to searching tuples
	movir #1 r4 ; start with checking tuple01
	jmp findTuple

run: movir #1 r4
jmp findTuple

end: halt
	
 

